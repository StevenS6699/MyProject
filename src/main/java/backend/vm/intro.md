VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。
类似于 Data Manager 是DB 的数据管理核心，Version Manager 是DB 的事务和数据版本的管理核心。
* 2PL 与 MVCC
* 冲突与 2PL
首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这两个操作相互冲突：
1. 这两个操作是由不同的事务执行的
2. 这两个操作操作的是同一个数据项
3. 这两个操作至少有一个是更新操作
   那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况： 
1) 两个不同事务的 U 操作冲突
2) 两个不同事务的 U、R 操作冲突
那么冲突或者不冲突，意义何在？
作用在于，交换两个互不冲突的操作的顺序，不会对最终的结果造成影响，而交换两个冲突操作的顺序，则是会有影响的。

* VM 的一个很重要的职责，就是实现了调度序列的可串行化。MYDB 采用两段锁协议（2PL）来实现。
* 采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。
  譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。
* 由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了事务间的相互阻塞，甚至可能导致死锁。DB为了提高事务处理的效率，降低阻塞概率，实现了MVCC。

* MVCC
* 在介绍 MVCC 之前，首先明确记录和版本的概念。
DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。
上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（Version）。
每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。
* DB 通过 MVCC，降低了事务的阻塞概率。
* 譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。
* 假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，DB 会返回一个较老版本的 X，例如 x2。
* 这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。
* 如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。

