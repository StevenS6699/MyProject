恢复策略：
DM 为上层模块，提供了两种操作，分别是插入新数据（I）和更新现有数据（U）。
在进行 I 和 U 操作之前，必须先进行对应的日志操作，在保证日志写入磁盘后，才进行数据操作。
这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。
日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后没有来得及同步到磁盘，数据库就发生了崩溃，后续也可以通过磁盘上的日志恢复该数据。
* 对于两种数据操作，DM 记录的日志如下：
* (Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x
* (Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx

单线程：
* 由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下利用日志恢复很简单，假设日志中最后一个事务是 Ti：
  对 Ti 之前所有的事务的日志，进行重做（redo）
  接着检查 Ti 的状态（XID 文件），如果 Ti 的状态是已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo）
  接着，是如何对事务 T 进行 redo：
  正序扫描事务 T 的所有日志
  如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置
  如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx
  undo 也很好理解：
  倒序扫描事务 T 的所有日志
  如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除
  如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx
  注意，DB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。
多线程：
* 规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。
* 规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。
DB 中，由于 VM 的存在，传递到 DM 层，真正执行的操作序列，都可以保证规定 1 和规定 2。
VM 如何保证这两条规定，会在 VM 层一节中说明。有了这两条规定，并发情况下日志的恢复也就很简单了：
* 重做所有崩溃时已完成（committed 或 aborted）的事务
* 撤销所有崩溃时未完成（active）的事务
* 在恢复后，数据库就会恢复到所有已完成事务结束，所有未完成事务尚未开始的状态。