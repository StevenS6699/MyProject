* TBM 实现了对字段结构和表结构的管理, 
* 这里的字段与表管理，不是管理各个条目中不同的字段的数值等信息，而是管理表和字段的结构数据，
* 例如表名、表字段信息和字段索引等
* 由于 TBM 基于 VM，单个字段信息和表信息都是直接保存在 Entry 中


* 一个数据库中存在多张表，TBM 使用链表的形式将其组织起来，每一张表都保存一个指向下一张表的 UID
* 对表和字段的操作，有一个很重要的步骤，就是计算 Where 条件的范围，目前 DB 的 Where 只支持两个条件的与和或。
* 例如有条件的 Delete，计算 Where，最终就需要获取到条件范围内所有的 UID。DB 只支持已索引字段作为 Where 的条件。
* 计算 Where 的范围，具体可以查看 Table 的 parseWhere() 和 calWhere() 方法，以及 Field 类的 calExp() 方法。
  由于 TBM 的表管理，使用的是链表串起的 Table 结构，所以就必须保存一个链表的头节点，
* 即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。
  DB 使用 Booter 类和 bt 文件，来管理 MYDB 的启动信息，
* 虽然现在所需的启动信息，只有一个：头表的 UID。Booter 类对外提供了两个方法：load 和 update，并保证了其原子性。
* update 在修改 bt 文件内容时，没有直接对 bt 文件进行修改，而是首先将内容写入一个 bt_tmp 文件中，随后将这个文件重命名为 bt 文件。
* 以期通过操作系统重命名文件的原子性，来保证操作的原子性。